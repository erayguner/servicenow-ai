import { handler } from './index';
import { ScanEvent, ScanResult } from './types';

// Mock AWS SDK clients
jest.mock('@aws-sdk/client-ecr');
jest.mock('@aws-sdk/client-lambda');
jest.mock('@aws-sdk/client-securityhub');
jest.mock('@aws-sdk/client-sns');
jest.mock('@aws-sdk/client-sqs');

describe('Security Vulnerability Scanner', () => {
  beforeEach(() => {
    process.env.SECURITY_HUB_ENABLED = 'true';
    process.env.NOTIFICATION_TOPIC_ARN = 'arn:aws:sns:us-east-1:123456789012:security-alerts';
    process.env.REMEDIATION_QUEUE_URL = 'https://sqs.us-east-1.amazonaws.com/123456789012/remediation';
    process.env.SEVERITY_THRESHOLD = 'MEDIUM';
    process.env.AWS_ACCOUNT_ID = '123456789012';
    process.env.AWS_REGION = 'us-east-1';
    jest.clearAllMocks();
  });

  describe('handler', () => {
    it('should perform vulnerability scan and return results', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result).toBeDefined();
      expect(result.scanId).toMatch(/^scan-\d+$/);
      expect(result.totalVulnerabilities).toBeGreaterThanOrEqual(0);
      expect(result.scanTypes).toContain('LAMBDA');
    });

    it('should scan Lambda functions', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
        lambdaFunctions: ['function-1', 'function-2'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result.scanTypes).toContain('LAMBDA');
      expect(result.scanDuration).toBeGreaterThan(0);
    });

    it('should scan Docker images', async () => {
      const event: ScanEvent = {
        scanTypes: ['DOCKER'],
        ecrRepositories: ['repo-1', 'repo-2'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result.scanTypes).toContain('DOCKER');
    });

    it('should scan package files', async () => {
      const event: ScanEvent = {
        scanTypes: ['PACKAGES'],
        packageFiles: ['/app/package.json'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result.scanTypes).toContain('PACKAGES');
    });

    it('should categorize vulnerabilities by severity', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA', 'DOCKER', 'PACKAGES'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result.criticalCount).toBeGreaterThanOrEqual(0);
      expect(result.highCount).toBeGreaterThanOrEqual(0);
      expect(result.mediumCount).toBeGreaterThanOrEqual(0);
      expect(result.lowCount).toBeGreaterThanOrEqual(0);
      expect(
        result.criticalCount + result.highCount + result.mediumCount + result.lowCount
      ).toBe(result.totalVulnerabilities);
    });
  });

  describe('Severity Filtering', () => {
    it('should filter by CRITICAL threshold', async () => {
      process.env.SEVERITY_THRESHOLD = 'CRITICAL';

      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      result.vulnerabilities.forEach((vuln) => {
        expect(vuln.severity).toBe('CRITICAL');
      });
    });

    it('should filter by HIGH threshold', async () => {
      process.env.SEVERITY_THRESHOLD = 'HIGH';

      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      result.vulnerabilities.forEach((vuln) => {
        expect(['CRITICAL', 'HIGH']).toContain(vuln.severity);
      });
    });

    it('should filter by MEDIUM threshold', async () => {
      process.env.SEVERITY_THRESHOLD = 'MEDIUM';

      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      result.vulnerabilities.forEach((vuln) => {
        expect(['CRITICAL', 'HIGH', 'MEDIUM']).toContain(vuln.severity);
      });
    });
  });

  describe('Security Hub Integration', () => {
    it('should report findings to Security Hub when enabled', async () => {
      process.env.SECURITY_HUB_ENABLED = 'true';

      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result).toBeDefined();
    });

    it('should not report to Security Hub when disabled', async () => {
      process.env.SECURITY_HUB_ENABLED = 'false';

      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result).toBeDefined();
    });
  });

  describe('Remediation Tickets', () => {
    it('should create tickets for critical vulnerabilities', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA', 'DOCKER'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result.remediationTicketsCreated).toBeGreaterThanOrEqual(0);
    });

    it('should track number of remediation tickets created', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(typeof result.remediationTicketsCreated).toBe('number');
    });
  });

  describe('Notifications', () => {
    it('should send notification when critical vulnerabilities found', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA', 'DOCKER'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result).toBeDefined();
    });
  });

  describe('Scan Duration', () => {
    it('should measure scan duration', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      expect(result.scanDuration).toBeGreaterThan(0);
      expect(typeof result.scanDuration).toBe('number');
    });
  });

  describe('Error Handling', () => {
    it('should handle errors gracefully', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
        lambdaFunctions: ['non-existent-function'],
      };

      await expect(handler(event, {} as any, {} as any)).rejects.toThrow();
    });
  });

  describe('Vulnerability Types', () => {
    it('should identify package vulnerabilities', async () => {
      const event: ScanEvent = {
        scanTypes: ['LAMBDA'],
      };

      const result = await handler(event, {} as any, {} as any);

      const packageVulns = result.vulnerabilities.filter((v) => v.type === 'PACKAGE');
      expect(packageVulns).toBeDefined();
    });

    it('should identify image vulnerabilities', async () => {
      const event: ScanEvent = {
        scanTypes: ['DOCKER'],
        ecrRepositories: ['test-repo'],
      };

      const result = await handler(event, {} as any, {} as any);

      const imageVulns = result.vulnerabilities.filter((v) => v.type === 'IMAGE');
      expect(imageVulns).toBeDefined();
    });
  });
});
