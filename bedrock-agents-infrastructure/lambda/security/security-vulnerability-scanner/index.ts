import { LambdaClient, ListFunctionsCommand } from '@aws-sdk/client-lambda';
import {
  SecurityHubClient,
  BatchImportFindingsCommand,
} from '@aws-sdk/client-securityhub';
import { SNSClient, PublishCommand } from '@aws-sdk/client-sns';
import { Handler } from 'aws-lambda';
import {
  ScanEvent,
  ScanResult,
  Vulnerability,
  PackageVulnerability,
  ImageVulnerability,
} from './types';
import {
  scanLambdaDependencies,
  scanDockerImage,
  scanPackageVersions,
  createSecurityHubFinding,
  createRemediationTicket,
  logger,
} from './utils';

const lambdaClient = new LambdaClient({});
const securityHubClient = new SecurityHubClient({});
const snsClient = new SNSClient({});

const SECURITY_HUB_ENABLED = process.env.SECURITY_HUB_ENABLED !== 'false';
const NOTIFICATION_TOPIC = process.env.NOTIFICATION_TOPIC_ARN || '';
const REMEDIATION_QUEUE = process.env.REMEDIATION_QUEUE_URL || '';
const SEVERITY_THRESHOLD = process.env.SEVERITY_THRESHOLD || 'MEDIUM';

export const handler: Handler<ScanEvent, ScanResult> = async (event) => {
  logger.info('Starting vulnerability scan', { event });

  const scanId = `scan-${Date.now()}`;
  const vulnerabilities: Vulnerability[] = [];
  const startTime = Date.now();

  try {
    const scanTypes = event.scanTypes || ['LAMBDA', 'DOCKER', 'PACKAGES'];

    // Scan Lambda dependencies
    if (scanTypes.includes('LAMBDA')) {
      const lambdaVulns = await scanAllLambdaFunctions(event.lambdaFunctions);
      vulnerabilities.push(...lambdaVulns);
    }

    // Scan Docker images
    if (scanTypes.includes('DOCKER') && event.ecrRepositories) {
      const dockerVulns = await scanAllDockerImages(event.ecrRepositories);
      vulnerabilities.push(...dockerVulns);
    }

    // Scan package versions
    if (scanTypes.includes('PACKAGES') && event.packageFiles) {
      const packageVulns = await scanAllPackages(event.packageFiles);
      vulnerabilities.push(...packageVulns);
    }

    // Filter by severity threshold
    const filteredVulns = filterBySeverity(vulnerabilities, SEVERITY_THRESHOLD);

    // Report to Security Hub
    if (SECURITY_HUB_ENABLED && filteredVulns.length > 0) {
      await reportToSecurityHub(filteredVulns, scanId);
    }

    // Create remediation tickets for critical/high vulnerabilities
    const criticalVulns = filteredVulns.filter(
      (v) => v.severity === 'CRITICAL' || v.severity === 'HIGH'
    );

    if (criticalVulns.length > 0 && REMEDIATION_QUEUE) {
      await createRemediationTickets(criticalVulns, scanId);
    }

    // Send notification if critical vulnerabilities found
    if (criticalVulns.length > 0 && NOTIFICATION_TOPIC) {
      await sendVulnerabilityNotification(criticalVulns, scanId);
    }

    const result: ScanResult = {
      scanId,
      timestamp: new Date().toISOString(),
      totalVulnerabilities: filteredVulns.length,
      criticalCount: filteredVulns.filter((v) => v.severity === 'CRITICAL').length,
      highCount: filteredVulns.filter((v) => v.severity === 'HIGH').length,
      mediumCount: filteredVulns.filter((v) => v.severity === 'MEDIUM').length,
      lowCount: filteredVulns.filter((v) => v.severity === 'LOW').length,
      vulnerabilities: filteredVulns,
      scanDuration: Date.now() - startTime,
      scanTypes,
      remediationTicketsCreated: criticalVulns.length,
    };

    logger.info('Vulnerability scan completed', { result });
    return result;
  } catch (error) {
    logger.error('Error during vulnerability scan', { error, scanId });
    throw error;
  }
};

async function scanAllLambdaFunctions(
  functionNames?: string[]
): Promise<PackageVulnerability[]> {
  const vulnerabilities: PackageVulnerability[] = [];

  try {
    let functions: string[] = [];

    if (functionNames && functionNames.length > 0) {
      functions = functionNames;
    } else {
      // List all Lambda functions
      const listResponse = await lambdaClient.send(new ListFunctionsCommand({}));
      functions = listResponse.Functions?.map((f) => f.FunctionName || '').filter(Boolean) || [];
    }

    logger.info(`Scanning ${functions.length} Lambda functions`);

    for (const functionName of functions) {
      try {
        const funcVulns = await scanLambdaDependencies(functionName);
        vulnerabilities.push(...funcVulns);
      } catch (error) {
        logger.error(`Error scanning Lambda function ${functionName}`, { error });
      }
    }
  } catch (error) {
    logger.error('Error scanning Lambda functions', { error });
  }

  return vulnerabilities;
}

async function scanAllDockerImages(repositories: string[]): Promise<ImageVulnerability[]> {
  const vulnerabilities: ImageVulnerability[] = [];

  for (const repoName of repositories) {
    try {
      const imageVulns = await scanDockerImage(repoName);
      vulnerabilities.push(...imageVulns);
    } catch (error) {
      logger.error(`Error scanning repository ${repoName}`, { error });
    }
  }

  return vulnerabilities;
}

async function scanAllPackages(packageFiles: string[]): Promise<PackageVulnerability[]> {
  const vulnerabilities: PackageVulnerability[] = [];

  for (const packageFile of packageFiles) {
    try {
      const pkgVulns = await scanPackageVersions(packageFile);
      vulnerabilities.push(...pkgVulns);
    } catch (error) {
      logger.error(`Error scanning package file ${packageFile}`, { error });
    }
  }

  return vulnerabilities;
}

function filterBySeverity(
  vulnerabilities: Vulnerability[],
  threshold: string
): Vulnerability[] {
  const severityOrder = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
  const thresholdIndex = severityOrder.indexOf(threshold);

  if (thresholdIndex === -1) {
    return vulnerabilities;
  }

  return vulnerabilities.filter((vuln) => {
    const vulnIndex = severityOrder.indexOf(vuln.severity);
    return vulnIndex >= thresholdIndex;
  });
}

async function reportToSecurityHub(
  vulnerabilities: Vulnerability[],
  scanId: string
): Promise<void> {
  try {
    const accountId = process.env.AWS_ACCOUNT_ID || '';
    const region = process.env.AWS_REGION || 'us-east-1';

    const findings = vulnerabilities.map((vuln) =>
      createSecurityHubFinding(vuln, scanId, accountId, region)
    );

    // Security Hub accepts max 100 findings per batch
    const batches = [];
    for (let i = 0; i < findings.length; i += 100) {
      batches.push(findings.slice(i, i + 100));
    }

    for (const batch of batches) {
      await securityHubClient.send(
        new BatchImportFindingsCommand({
          Findings: batch,
        })
      );
    }

    logger.info(`Reported ${findings.length} findings to Security Hub`);
  } catch (error) {
    logger.error('Error reporting to Security Hub', { error });
  }
}

async function createRemediationTickets(
  vulnerabilities: Vulnerability[],
  scanId: string
): Promise<void> {
  for (const vuln of vulnerabilities) {
    try {
      await createRemediationTicket(vuln, scanId, REMEDIATION_QUEUE);
    } catch (error) {
      logger.error('Error creating remediation ticket', { error, vuln });
    }
  }
}

async function sendVulnerabilityNotification(
  vulnerabilities: Vulnerability[],
  scanId: string
): Promise<void> {
  try {
    const criticalCount = vulnerabilities.filter((v) => v.severity === 'CRITICAL').length;
    const highCount = vulnerabilities.filter((v) => v.severity === 'HIGH').length;

    const message = {
      scanId,
      timestamp: new Date().toISOString(),
      summary: {
        total: vulnerabilities.length,
        critical: criticalCount,
        high: highCount,
      },
      topVulnerabilities: vulnerabilities.slice(0, 10).map((v) => ({
        id: v.id,
        title: v.title,
        severity: v.severity,
        package: 'packageName' in v ? v.packageName : 'imageUri' in v ? v.imageUri : 'unknown',
        cvss: v.cvssScore,
      })),
    };

    await snsClient.send(
      new PublishCommand({
        TopicArn: NOTIFICATION_TOPIC,
        Subject: `ðŸš¨ Critical Vulnerabilities Detected - Scan ${scanId}`,
        Message: JSON.stringify(message, null, 2),
      })
    );

    logger.info('Vulnerability notification sent', { scanId });
  } catch (error) {
    logger.error('Error sending notification', { error });
  }
}
