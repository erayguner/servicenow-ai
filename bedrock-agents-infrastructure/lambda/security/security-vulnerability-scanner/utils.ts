import {
  ECRClient,
  DescribeImageScanFindingsCommand,
  StartImageScanCommand,
  DescribeImagesCommand,
} from '@aws-sdk/client-ecr';
import { LambdaClient, GetFunctionCommand } from '@aws-sdk/client-lambda';
import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs';
import {
  PackageVulnerability,
  ImageVulnerability,
  Vulnerability,
  LoggerContext,
} from './types';

const ecrClient = new ECRClient({});
const lambdaClient = new LambdaClient({});
const sqsClient = new SQSClient({});

export const logger = {
  info: (message: string, context?: LoggerContext) => {
    console.log(
      JSON.stringify({ level: 'INFO', message, ...context, timestamp: new Date().toISOString() })
    );
  },
  warn: (message: string, context?: LoggerContext) => {
    console.warn(
      JSON.stringify({ level: 'WARN', message, ...context, timestamp: new Date().toISOString() })
    );
  },
  error: (message: string, context?: LoggerContext) => {
    console.error(
      JSON.stringify({ level: 'ERROR', message, ...context, timestamp: new Date().toISOString() })
    );
  },
};

export async function scanLambdaDependencies(
  functionName: string
): Promise<PackageVulnerability[]> {
  const vulnerabilities: PackageVulnerability[] = [];

  try {
    const funcResponse = await lambdaClient.send(
      new GetFunctionCommand({ FunctionName: functionName })
    );

    const runtime = funcResponse.Configuration?.Runtime || '';

    // Simulate dependency scanning
    // In production, you would:
    // 1. Download the function code
    // 2. Parse package.json/requirements.txt/etc.
    // 3. Check against vulnerability databases (npm audit, safety, etc.)
    // 4. Use AWS CodeGuru or third-party tools

    logger.info(`Scanning dependencies for Lambda function ${functionName}`, { runtime });

    // Example vulnerabilities (mock data)
    const mockVulnerabilities = generateMockPackageVulnerabilities(functionName, runtime);
    vulnerabilities.push(...mockVulnerabilities);
  } catch (error) {
    logger.error(`Error scanning Lambda function ${functionName}`, { error });
  }

  return vulnerabilities;
}

export async function scanDockerImage(repositoryName: string): Promise<ImageVulnerability[]> {
  const vulnerabilities: ImageVulnerability[] = [];

  try {
    // List images in repository
    const imagesResponse = await ecrClient.send(
      new DescribeImagesCommand({
        repositoryName,
        maxResults: 100,
      })
    );

    const images = imagesResponse.imageDetails || [];

    for (const image of images) {
      if (!image.imageDigest) continue;

      try {
        // Start image scan
        await ecrClient.send(
          new StartImageScanCommand({
            repositoryName,
            imageId: {
              imageDigest: image.imageDigest,
            },
          })
        );

        // Wait a bit for scan to complete (in production, use async pattern)
        await new Promise((resolve) => setTimeout(resolve, 2000));

        // Get scan findings
        const scanResponse = await ecrClient.send(
          new DescribeImageScanFindingsCommand({
            repositoryName,
            imageId: {
              imageDigest: image.imageDigest,
            },
          })
        );

        const findings = scanResponse.imageScanFindings?.findings || [];

        for (const finding of findings) {
          vulnerabilities.push({
            type: 'IMAGE',
            id: `${repositoryName}-${image.imageDigest}-${finding.name}`,
            title: finding.name || 'Unknown Vulnerability',
            description: finding.description || '',
            severity: mapECRSeverity(finding.severity || 'INFORMATIONAL'),
            cvssScore: finding.attributes?.find((a) => a.key === 'CVSS2_SCORE')?.value
              ? parseFloat(finding.attributes.find((a) => a.key === 'CVSS2_SCORE')!.value!)
              : undefined,
            cveId: finding.name,
            imageUri: `${repositoryName}@${image.imageDigest}`,
            imageDigest: image.imageDigest,
            repositoryName,
            packageName: finding.attributes?.find((a) => a.key === 'package_name')?.value,
            packageVersion: finding.attributes?.find((a) => a.key === 'package_version')?.value,
            riskScore: assessRiskScore({
              severity: mapECRSeverity(finding.severity || 'INFORMATIONAL'),
              cvssScore: finding.attributes?.find((a) => a.key === 'CVSS2_SCORE')?.value
                ? parseFloat(finding.attributes.find((a) => a.key === 'CVSS2_SCORE')!.value!)
                : undefined,
            }),
          });
        }
      } catch (error) {
        logger.error(`Error scanning image ${image.imageDigest}`, { error });
      }
    }
  } catch (error) {
    logger.error(`Error scanning repository ${repositoryName}`, { error });
  }

  return vulnerabilities;
}

export async function scanPackageVersions(
  packageFile: string
): Promise<PackageVulnerability[]> {
  const vulnerabilities: PackageVulnerability[] = [];

  try {
    // In production, you would:
    // 1. Read the package file (package.json, requirements.txt, etc.)
    // 2. Extract all dependencies
    // 3. Check each against vulnerability databases
    // 4. Use tools like npm audit, pip-audit, OWASP Dependency-Check

    logger.info(`Scanning package file ${packageFile}`);

    // Mock implementation
    const mockVulns = generateMockPackageVulnerabilities(packageFile, 'nodejs');
    vulnerabilities.push(...mockVulns);
  } catch (error) {
    logger.error(`Error scanning package file ${packageFile}`, { error });
  }

  return vulnerabilities;
}

function mapECRSeverity(ecrSeverity: string): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
  switch (ecrSeverity.toUpperCase()) {
    case 'CRITICAL':
      return 'CRITICAL';
    case 'HIGH':
      return 'HIGH';
    case 'MEDIUM':
      return 'MEDIUM';
    case 'LOW':
    case 'INFORMATIONAL':
    case 'UNDEFINED':
    default:
      return 'LOW';
  }
}

export function assessRiskScore(params: {
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  cvssScore?: number;
  exploitAvailable?: boolean;
  patchAvailable?: boolean;
}): number {
  let score = 0;

  // Base score from severity
  switch (params.severity) {
    case 'CRITICAL':
      score += 90;
      break;
    case 'HIGH':
      score += 70;
      break;
    case 'MEDIUM':
      score += 40;
      break;
    case 'LOW':
      score += 10;
      break;
  }

  // Adjust for CVSS score
  if (params.cvssScore) {
    score = Math.max(score, params.cvssScore * 10);
  }

  // Increase if exploit available
  if (params.exploitAvailable) {
    score += 20;
  }

  // Decrease if patch available
  if (params.patchAvailable) {
    score -= 10;
  }

  return Math.min(Math.max(score, 0), 100);
}

export function createSecurityHubFinding(
  vulnerability: Vulnerability,
  scanId: string,
  accountId: string,
  region: string
): any {
  const severityMapping = {
    CRITICAL: 90,
    HIGH: 70,
    MEDIUM: 40,
    LOW: 10,
  };

  const finding: any = {
    SchemaVersion: '2018-10-08',
    Id: `${scanId}/${vulnerability.id}`,
    ProductArn: `arn:aws:securityhub:${region}:${accountId}:product/${accountId}/default`,
    GeneratorId: 'security-vulnerability-scanner',
    AwsAccountId: accountId,
    Types: ['Software and Configuration Checks/Vulnerabilities/CVE'],
    CreatedAt: new Date().toISOString(),
    UpdatedAt: new Date().toISOString(),
    Severity: {
      Label: vulnerability.severity,
      Normalized: severityMapping[vulnerability.severity],
    },
    Title: vulnerability.title,
    Description: vulnerability.description,
    Remediation: {
      Recommendation: {
        Text: vulnerability.remediation || 'Update to the latest version',
      },
    },
  };

  if (vulnerability.type === 'PACKAGE') {
    finding.Resources = [
      {
        Type: 'AwsLambdaFunction',
        Id: vulnerability.functionName || vulnerability.filePath || 'unknown',
        Details: {
          Other: {
            PackageName: vulnerability.packageName,
            PackageVersion: vulnerability.packageVersion,
            FixedVersion: vulnerability.fixedVersion || 'N/A',
            PackageManager: vulnerability.packageManager,
          },
        },
      },
    ];
  } else if (vulnerability.type === 'IMAGE') {
    finding.Resources = [
      {
        Type: 'AwsEcrContainerImage',
        Id: vulnerability.imageUri,
        Details: {
          AwsEcrContainerImage: {
            RepositoryName: vulnerability.repositoryName,
            ImageDigest: vulnerability.imageDigest,
          },
        },
      },
    ];
  }

  if (vulnerability.cveId) {
    finding.Vulnerabilities = [
      {
        Id: vulnerability.cveId,
        VulnerablePackages: [
          {
            Name:
              vulnerability.type === 'PACKAGE'
                ? vulnerability.packageName
                : vulnerability.packageName || 'unknown',
            Version:
              vulnerability.type === 'PACKAGE'
                ? vulnerability.packageVersion
                : vulnerability.packageVersion || 'unknown',
            FixedInVersion: vulnerability.fixedVersion,
          },
        ],
        Cvss: vulnerability.cvssScore
          ? [
              {
                BaseScore: vulnerability.cvssScore,
              },
            ]
          : undefined,
      },
    ];
  }

  return finding;
}

export async function createRemediationTicket(
  vulnerability: Vulnerability,
  scanId: string,
  queueUrl: string
): Promise<void> {
  try {
    const priority = getPriority(vulnerability.severity);

    const ticket = {
      ticketId: `VULN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      scanId,
      vulnerability,
      priority,
      status: 'OPEN',
      createdAt: new Date().toISOString(),
    };

    await sqsClient.send(
      new SendMessageCommand({
        QueueUrl: queueUrl,
        MessageBody: JSON.stringify(ticket),
        MessageAttributes: {
          Severity: {
            DataType: 'String',
            StringValue: vulnerability.severity,
          },
          Priority: {
            DataType: 'String',
            StringValue: priority,
          },
        },
      })
    );

    logger.info('Remediation ticket created', {
      ticketId: ticket.ticketId,
      vulnerabilityId: vulnerability.id,
    });
  } catch (error) {
    logger.error('Error creating remediation ticket', { error, vulnerability });
  }
}

function getPriority(severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'): 'P0' | 'P1' | 'P2' | 'P3' {
  switch (severity) {
    case 'CRITICAL':
      return 'P0';
    case 'HIGH':
      return 'P1';
    case 'MEDIUM':
      return 'P2';
    case 'LOW':
    default:
      return 'P3';
  }
}

function generateMockPackageVulnerabilities(
  source: string,
  runtime: string
): PackageVulnerability[] {
  // This is mock data for testing - in production, use real vulnerability databases
  const mockPackages = [
    {
      name: 'lodash',
      version: '4.17.15',
      cve: 'CVE-2020-8203',
      severity: 'HIGH' as const,
      fixedVersion: '4.17.21',
    },
    {
      name: 'axios',
      version: '0.21.0',
      cve: 'CVE-2021-3749',
      severity: 'MEDIUM' as const,
      fixedVersion: '0.21.4',
    },
  ];

  return mockPackages.map((pkg) => ({
    type: 'PACKAGE',
    id: `${source}-${pkg.name}-${pkg.cve}`,
    title: `${pkg.cve} in ${pkg.name}`,
    description: `Vulnerability found in ${pkg.name}@${pkg.version}`,
    severity: pkg.severity,
    packageName: pkg.name,
    packageVersion: pkg.version,
    fixedVersion: pkg.fixedVersion,
    packageManager: runtime.includes('node') ? ('npm' as const) : ('pip' as const),
    cveId: pkg.cve,
    functionName: source,
    remediation: `Update ${pkg.name} to version ${pkg.fixedVersion} or later`,
    riskScore: assessRiskScore({ severity: pkg.severity, patchAvailable: true }),
  }));
}
